# JSで画像生成 QRコード編


## 概要
### 生成手順
- 文字種別を判定して使用するモードを決定
	- 数字、英数字、8bit、漢字モードがある
- 決定したモードで文字列をエンコード
	- 同時にヘッダー付与
	- ヘッダの一部はバージョンで長さが変動する
- エンコード済みデータの長さからバージョンを決定
	- 同時にデータ長が決定する
- 埋め草bit,byteしてバージョンが要求するデータ長に合わせる
- バージョンに応じたブロック数に分割してブロック毎にRS符号を付与
- 各ブロックから順番にデータを取り出す
	- インターリブ配置
- 機能パターンモジュールを描画
- 型番情報にBCH符号を付与して描画
	- バージョン7以上のみ
- インターリブ配置したデータを描画領域右下から順に配置
- 8通りのマスクから最適なマスクを選択
- 形式情報にBCH符号を付与して描画
	- エラー訂正レベルと使用したマスクを含む
- 完成


## day0 2024/1/29
### Reed Solomon 符号
Reed Solomon符号、RS符号とはデータが欠損した場合において、欠損の検出及び元のデータの復号を可能にする追加のデータである。
以下はデータ本体を表現する配列wとRS符号の長さnを取り、RS符号を配列で返す関数rseである。

```js
const
rse=(w,n)=>((
	{exp,log}=[...Array(255)].reduce((a,_,i)=>(a.exp[i]=a.x,a.log[a.x]=i,a.x*=2,(a.x>255)&&(a.x^=0x11d),a),{x:1,exp:[],log:[]}),
	mul=(x,y)=>x&&y&&(x=log[x]+log[y],exp[x]||exp[x-255]),pow=(x,y)=>exp[(log[x]*y)%255],
	g=[...Array(n)].reduce((b,_,k)=>[1,pow(2,k)].reduce((a,y,j)=>(b.forEach((x,i)=>a[i+j]^=mul(x,y)),a),[]),[1]).slice(1)
)=>w.reduce((a,_,i)=>(a[i]&&g.forEach((x,j)=>a[i+j+1]^=mul(x,a[i])),a),w.slice()).slice(-n))();
```
## day1 10/6
文字列をエンコードしたデータを含むブロックを作成する。
```
mode 4bit | length 8~16bit | data Nbit
```
### 符号化
文字種別を判別する。
数字>英数字>漢字>8bitモードの優先順で決定する。
出力は整形のために複数の形式を含むオブジェクトである。
以下は数字モードのマップn、英数モードのマップa、そして漢字モードのマップkを含むmを含むdの宣言及び、文字列wを取りモードに対応する数字を返す関数modeである。
```js
const
d={
	m:{
		enum:['NUM','ALPHANUM','BYTE','KANJI'],
		n:[...Array(10)].reduce((a,_,i)=>(a[i]=i,a),{}),
		a:[...'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:'].reduce((a,x,i)=>(a[x]=i,a),{}),
		k:[...Array(86)].reduce((a,y,_y)=>(y=(_y/2|0)+0x81+0x40*(61<_y),[...Array(_y==85?33:94)].forEach((_,x)=>(x+=_y&1?0x9f:0x40+(62<x),
			a[td_sjis.decode(new Uint8Array([y,x]))]=(y-(0x9f<y?0xc1:0x81))*0xc0+x-0x40
		)),a),{})
	}
},
mode=(w)=>(w=[...w].reduce((a,x)=>(Object.keys(a).forEach(i=>(x in d.m[i])||(a[i]=0)),a),{n:1,a:1,k:1}),w=w.n?0:w.a?1:w.k?3:2,{x:1<<w,l:4,s:w});
```

次に文字種別からモードを決定したらモードに応じた手続きでエンコードする。
あとでbit単位で詰める必要があるのでデータ本体とbit単位のデータ長を持つオブジェクトの配列を返す。
以下は文字列群wを受け取り、対応するqrコードの画素データを返すことを目標に書かれた関数qrの一部である。
ここで、関数qrは文字列の配列wを受け取り、wに、文字列本体w、モードを表すオブジェクトm、そしてエンコード済みのデータdを含むオブジェクトを再代入している。

```js
const
qr=w=>(
	w={
		d:w.map(w=>(
			w={w,m:mode(w)},
			w.d=([
				_=>[...Array(Math.ceil(w.w.length/3))].map((x,i)=>(x=w.w.slice(i*3,++i*3),{x:+x,l:[0,4,7,10][x.length]})),// NUM
				_=>[...Array(Math.ceil(w.w.length/2))].map((x,i)=>(x=w.w.slice(i*2,++i*2),{x:[...x].reduce((a,x)=>a=a*45+d.m.a[x],0),l:[0,6,11][x.length]})),// ALPHANUM
				_=>[...te.encode(w.w)].map(x=>({x,l:8})),// BYTE
				_=>[...w.w].map(x=>({x:d.m.k[x],l:13}))// KANJI
			][w.m.s])(),
```

最後にヘッダーを用意する。
ヘッダーに必要な情報はモードとデータ長とQRコードのバージョン(大きさ)である。
しかしQRコードのバージョンはヘッダーなしでは決定できないので、バージョン番号を引数に取りデータ全体の長さを返す関数で用意する。
再代入されたオブジェクトwに対して、バージョン番号を取りデータ長を表すオブジェクトを返す関数c、そしてバージョン番号を取りヘッダを含むデータ長を返す関数lをプロパティとして定義している。

```js
			w.c=v=>({x:(w['wd'[w.m.s>>1]].length),l:[[10,12,14],[9,11,13],[8,16,16],[8,10,12]][w.m.s][(9<v)+(26<v)]}),// データ長
			w.l=v=>w.m.l+w.c(v).l+w.d.reduce((a,x)=>a+x.l,0),// ヘッダを含むデータ長
			w
		))
	}
);

```

## day2 10/7
### 表1
表1とはQRコードの仕様書JISX0510 p17に記載されている、バージョン番号と対応するデータ容量についての表である。
表を定数としてそのまま書き写すのは美しくないと考える。
以下はこれをバージョン番号から導出するコード、具体的には
バージョン番号に対して表1に存在するパラメータを含むオブジェクトを返すオブジェクトd.vの宣言である。
```js
d.v=[...Array(40)].reduce((a,x={},i)=>(
	// JISX0510:2018 p17 表1
	x.l=21+i*4,// モジュール数/辺
	x.fpm=(_=>(// 機能パターンモジュール
		_.ap=Math.max(0,_.apps**2-3)*25,// 位置合わせパターンモジュール
		_.tp=(x.l-16-Math.max(0,_.apps-2)*5)*2,// タイミングパターンモジュール
		_.pp+_.ap+_.tp
	))({
		pp:192,// 位置検出及び分離パターンモジュール
		apps:i?((i+1)/7|0)+2:0// 位置合わせパターン/辺
	}),
	x.im=31+(5<i)*18*2,// 形式情報及び型番情報モジュール
	x.dm=x.l**2-x.fpm-x.im,// データモジュール
	x.dw=x.dm>>3,// データ容量
	x.dr=x.dm&7,// 残余ビット

	a[x.ver=i+1]=x,a
),{});
```

## day3 10/8
### 表9で悩む
表9とはQRコードの仕様書JISX0510 p36に記載されている、バージョン番号と対応するブロック数、誤り訂正についての表である。
規則性が殆ど読み取れないので、これを実装するとはつまるところ表を書き写すのみとなるのである。
非常に不本意かつ苦しい行為である。
今日は休むのだ。

## day4 10/9
### 表9の実装
表1の再実装と一緒に実装する。
同時に表E.1も実装した。
表E.1はバージョン番号に対してalignment moduleの座標を定義する表である。
以下はバージョン番号に対して、表1、表9、及び表E.1に存在するパラメータを含むオブジェクトを返すオブジェクトd.vの宣言である。
エラー訂正レベル毎の定義はバージョンに対するオブジェクトの内部にて行われる。

```js
d.v=[// [...ec,...ap] ec[lv=0~3]:[short_data_l,short_blk_n(,long_blk_n)], ap:[6,...ap,l-7]
	[[19,1],[16,1],[13,1],[9,1]],[[34,1],[28,1],[22,1],[16,1]],
	[[55,1],[44,1],[17,2],[13,2]],[[80,1],[32,2],[24,2],[9,4]],
	[[108,1],[43,2],[15,2,2],[11,2,2]],[[68,2],[27,4],[19,4],[15,4]],
	[[78,2],[31,4],[14,2,4],[13,4,1],22],[[97,2],[38,2,2],[18,4,2],[14,4,2],24],
	[[116,2],[36,3,2],[16,4,4],[12,4,4],26],[[68,2,2],[43,4,1],[19,6,2],[15,6,2],28],
	[[81,4],[50,1,4],[22,4,4],[12,3,8],30],[[92,2,2],[36,6,2],[20,4,6],[14,7,4],32],
	[[107,4],[37,8,1],[20,8,4],[11,12,4],34],[[115,3,1],[40,4,5],[16,11,5],[12,11,5],26,46],
	[[87,5,1],[41,5,5],[24,5,7],[12,11,7],26,48],[[98,5,1],[45,7,3],[19,15,2],[15,3,13],26,50],
	[[107,1,5],[46,10,1],[22,1,15],[14,2,17],30,54],[[120,5,1],[43,9,4],[22,17,1],[14,2,19],30,56],
	[[113,3,4],[44,3,11],[21,17,4],[13,9,16],30,58],[[107,3,5],[41,3,13],[24,15,5],[15,15,10],34,62],
	[[116,4,4],[42,17],[22,17,6],[16,19,6],28,50,72],[[111,2,7],[46,17],[24,7,16],[13,34],26,50,74],
	[[121,4,5],[47,4,14],[24,11,14],[15,16,14],30,54,78],[[117,6,4],[45,6,14],[24,11,16],[16,30,2],28,54,80],
	[[106,8,4],[47,8,13],[24,7,22],[15,22,13],32,58,84],[[114,10,2],[46,19,4],[22,28,6],[16,33,4],30,58,86],
	[[122,8,4],[45,22,3],[23,8,26],[15,12,28],34,62,90],[[117,3,10],[45,3,23],[24,4,31],[15,11,31],26,50,74,98],
	[[116,7,7],[45,21,7],[23,1,37],[15,19,26],30,54,78,102],[[115,5,10],[47,19,10],[24,15,25],[15,23,25],26,52,78,104],
	[[115,13,3],[46,2,29],[24,42,1],[15,23,28],30,56,82,108],[[115,17],[46,10,23],[24,10,35],[15,19,35],34,60,86,112],
	[[115,17,1],[46,14,21],[24,29,19],[15,11,46],30,58,86,114],[[115,13,6],[46,14,23],[24,44,7],[16,59,1],34,62,90,118],
	[[121,12,7],[47,12,26],[24,39,14],[15,22,41],30,54,78,102,126],[[121,6,14],[47,6,34],[24,46,10],[15,2,64],24,50,76,102,128],
	[[122,17,4],[46,29,14],[24,49,10],[15,24,46],28,54,80,106,132],[[122,4,18],[46,13,32],[24,48,14],[15,42,32],32,58,84,110,136],
	[[117,20,4],[47,40,7],[24,43,22],[15,10,67],26,54,82,110,138],[[118,19,6],[47,18,31],[24,34,34],[15,20,61],30,58,86,114,142]
].reduce((a,x,i)=>(
	x={_:x},x.l=21+i*4,x.ap=i?[6,...x._.slice(4),x.l-7]:[],// モジュール数/辺 位置合わせパターン座標
	x.de=(x.l**2-(192+Math.max(0,x.ap.length**2-3)*25+(x.l-16-Math.max(0,x.ap.length-2)*5)*2)-(31+(5<i)*36))>>3,// データ容量 (size-(pos+align-timing)-info)/8 cf.p17表1
	x.lv=x._.slice(0,4).map((y,lv)=>(y=y.slice(1).reduce((a,n,i)=>(a.b.push(Array(n).fill(y[0]+i)),a.d+=(y[0]+i)*n,a),{b:[],d:0}),y.b=y.b.flat(),{lv,b:y.b,d:y.d,e:(x.de-y.d)/y.b.length})),// エラー訂正 cf.p36表9
	delete x._,a[x.v=i+1]=x,a
),{});
```
## day5 10/10
### バージョンの自動判定
表9からfindでデータ量が容量以下に収まるバージョンを探索する。
以下は前述にて定義されたd.vを用いて、渡された文字列のエンコード済みデータwを格納可能なバージョンw.vを算出し定義するコードである。
```js
w.v=d.v[Object.values(d.v).find(x=>(w.d.reduce((a,y)=>a+y.l(x.v),0)<=x.lv[ecl].d<<3))]
```

### パディング、RS符号の生成、インターリーブ
### 描画系
### PNGエンコーダの修正
## day6 10/11
### パターン描画
### BCH符号
### マスク
### 完成
### 部報の執筆
